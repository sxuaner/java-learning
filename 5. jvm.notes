# Which JVM is used now since java SE 9 
In Oracle Java Runtime Environment (JRE) 8 and earlier, different implementations of the JVM, 
(the client VM, server VM, and minimal VM) were supported for configurations commonly used as clients,
as servers, and for embedded systems. Because most systems can now take advantage of the server VM, 
the Oracle Java Runtime Environment (JRE) 9 provides only that VM implementation.



// differences between heap and stack
// https://docs.oracle.com/en/java/javase
// https://javarevisited.blogspot.com/2012/07/when-class-loading-initialization-java-example.html#axzz717pzj7Kj


# Gabage Collector Basics
GC for SE7:
https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html


# JVM concepts
https://javapapers.com/core-java/java-jvm-memory-types/


# Java is platform-independent
Java Virtual Machine

#
The Java Virtual Machine (JVM) is an abstract computing machine. The JVM is a program that looks like a machine to 
the programs written to execute in it. This way, Java programs are written to the same set of interfaces and libraries. 
Each JVM implementation for a specific operating system, translates the Java programming instructions into instructions 
and commands that run on the local operating system. This way, Java programs achieve platform independence.

The Java virtual machine knows nothing of the Java programming language, only of a particular binary format, the class file format. A class file 
contains Java virtual machine instructions (or bytecodes) and a symbol table, as well as other ancillary information
! What knows the Java programming language? the compiler

# Performance Basics
Typically, when tuning a Java application, the focus is on one of two main goals: responsiveness or throughput.

Responsiveness
Responsiveness refers to how quickly an application or system responds with a requested piece of data. Examples include:
How quickly a desktop UI responds to an event
How fast a website returns a page
How fast a database query is returned
For applications that focus on responsiveness, large pause times are not acceptable. The focus is on responding in short periods of time.

Throughput
Throughput focuses on maximizing the amount of work by an application in a specific period of time. 
Examples of how throughput might be measured include
The number of transactions completed in a given time.
The number of jobs that a batch program can complete in an hour.
The number of database queries that can be completed in an hour.
High pause times are acceptable for applications that focus on throughput. Since high throughput applications focus 
on benchmarks over longer periods of time, quick response time is not a consideration.

# What is Automatic Garbage Collection?
Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and 
which are not, and deleting the unused objects. An in use object, or a referenced object, means that some part of your
 program still maintains a pointer to that object. An unused object, or unreferenced object, is no longer referenced 
 by any part of your program. So the memory used by an unreferenced object can be reclaimed.

 # 
 In a programming language like C, allocating and deallocating memory is a manual process. In Java, process of 
 deallocating memory is handled automatically by the garbage collector. The basic process can be described as follows.

Step 1: Marking
The first step in the process is called marking. This is where the garbage collector identifies which pieces of memory 
are in use and which are not. All objects are scanned in the marking phase to make this determination. This can be 
a very time consuming process if all objects in a system must be scanned.

Step 2: Normal Deletion
Normal deletion removes unreferenced objects leaving referenced objects and pointers to free space.
The memory allocator holds references to blocks of free space where new object can be allocated.

Step 2 addition: Deletion with Compacting
To further improve performance, in addition to deleting unreferenced objects, you can also compact the remaining 
referenced objects. By moving referenced object together, this makes new memory allocation much easier and faster.

! compact: adj consisting of parts that are positioned together closely or in a tidy way, using very 
! little space
! verb: to press something together in a tight and solid way

# Why Generational Garbage Collection?

As stated earlier, having to mark and compact all the objects in a JVM is inefficient. As more and more objects 
are allocated, the list of objects grows and grows leading to longer and longer garbage collection time. 
!However, empirical analysis of applications has shown that most objects are short lived.

# JVM Generations
JVM Generations

The information learned from the object allocation behavior can be used to enhance the performance of the JVM. 
Therefore, the heap is broken up into smaller parts or generations. The heap parts are: 
!Young Generation, 
!Old or Tenured Generation 
!Permanent Generation.
tenure: being the legal owner of land, a job, or an official public position, or the period of time during which you 
own it
tenured: having been given tenure (= the right to remain permanently in a job, usually one in education)

#The Young Generation# is where all new objects are allocated and aged. When the young generation fills up, this causes
a minor garbage collection. Minor collections can be optimized assuming a high object mortality rate. A young 
generation full of dead objects is collected very quickly. Some surviving objects are aged and eventually move to the
old generation.

#Stop the World Event# - !All minor garbage collections are "Stop the World" events.! This means that all application 
threads are stopped until the operation completes. Minor garbage collections are always Stop the World events.

#The Old Generation# is used to store long surviving objects. Typically, a threshold is set for young generation object 
and when that age is met, the object gets moved to the old generation. Eventually the old generation needs to be 
collected. This event is called a major garbage collection.

!Major garbage collection are also Stop the World events!. Often a major collection is much slower because it involves 
all live objects. So for Responsive applications, major garbage collections should be minimized. Also note, that the 
length of the Stop the World event for a major garbage collection is affected by the kind of garbage collector that 
is used for the old generation space.

The Permanent generation contains metadata required by the JVM to describe the classes and methods used in the 
application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. 
In addition, Java SE library classes and methods may be stored here.

Classes may get collected (unloaded) if the JVM finds they are no longer needed and space may be needed for other 
classes. The permanent generation is included in a full garbage collection.

(2) Tuning GC with JVM 5 - Section 3 Generations
The Generational Garbage Collection Process
Now that you understand why the heap is separted into different generations, it is time to look at how exactly these 
spaces interact. The pictures that follow walks through the object allocation and aging process in the JVM.

First, any new objects are allocated to the eden space. Both survivor spaces start out empty.
When the eden space fills up, a minor garbage collection is triggered.
! Eden /i:den/ in the Bible, the garden where the first humans, Adam and Eve, lived in perfect happiness before they 
! did not obey God and were ordered by him to leave
Referenced objects are moved to the first survivor space. Unreferenced objects are deleted when the eden space is cleared.
At the next minor GC, the same thing happens for the eden space. Unreferenced objects are deleted and referenced objects are moved to a survivor space. However, in this case, they are moved to the second survivor space (S1). In addition, objects from the last minor GC on the first survivor space (S0) have their age incremented and get moved to S1. Once all surviving objects have been moved to S1, both S0 and eden are cleared. Notice we now have differently aged object in the survivor space.

images/gcslides/Slide8.png
At the next minor GC, the same process repeats. However this time the survivor spaces switch. Referenced objects are moved to S0. Surviving objects are aged. Eden and S1 are cleared.

images/gcslides/Slide9.png
This slide demonstrates promotion. After a minor GC, when aged objects reach a certain age threshold (8 in this example) they are promoted from young generation to old generation.

images/gcslides/Slide7.png
As minor GCs continue to occure objects will continue to be promoted to the old generation space.

images/gcslides/Slide10.png
So that pretty much covers the entire process with the young generation. Eventually, a major GC will be performed on the old generation which cleans up and compacts that space.

images/gcslides/Slide11.png
 
Performing Your Own Observations
 
Java Garbage Collectors
 
Summary
Help OLL About Oracle Contact Us Terms of Use
