
# As you know, a class provides the blueprint for objects;

# What is a StringBuffer

## How are java classes allocated and loaded into JVM?

##Load sequence of java class

##Check and unchecked exceptions, errors
Checked exceptions are the ones by compilor. 
unchecked exceptions are the ones determined by JVM. Arithmetic Exception (zero is divided)
Errors are the ones returned by OS for instance OutOfMemeoryError, StackOverFlowError

# print() and println() difference
The print() and println() methods are essentially the same; they both write their String argument to the stream. The one difference between
 the two methods is that println() appends a newline character to the end of its output while print() does not. In other words, this
    [java]
    System.out.print("Duke is not a penguin!\n");
    // is equivalent to this
    System.out.println("Duke is not a penguin!");
    [end]

! ArrayList is not an array but a list!!!

# toString() in Object class
    [java]
    public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
    [end]

# Anonymous class
    [java]
    Runnable myRunnable = new Runnable(){
                                public void run(){
                                    System.out.println("Runnable running");
                                            }
                                        };
    [end]
http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html


# How hashtable works
HashMap in Java works on hashing principles. It is a data structure which allows us to store object and retrieve it in constant time !O(1)! provided we know the key. 
In hashing, hash functions are used to link key and value in HashMap. 
Objects are stored by calling put(key, value) method of HashMap and retrieved by calling get(key) method. 
!When we call put method, the hashcode() method of the key object is called so that the hash function of the map can find a bucket location to store value object, 
which is actually an index of the internal array, known as the table.

! What does O(1) mean?


Read more: https://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html#ixzz717vg30l1

# HashTable and Ha]shMap

# dot notation( It's not an operator)
"".value

# Method reference
You use lambda expressions to create anonymous methods. Sometimes, however, a lambda expression does 
nothing but call an existing method. In those cases, it's often clearer to refer to the existing method 
by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for 
methods that already have a name.

Kind	                                Syntax	                                                    Examples
Reference to a static method	        ContainingClass::staticMethodName	                        Person::compareByAge
                                                                                                    MethodReferencesExamples::appendStrings 

Reference to an instance method         containingObject::instanceMethodName                        myComparisonProvider::compareByName
of a particular object		                                                                        myApp::appendStrings2
                    
Reference to an instance method of an   ContainingType::methodName                                  String::compareToIgnoreCase
arbitrary object of a particular type		                                                        String::concat

Reference to a constructor	            ClassName::new	                                            HashSet::new

# new keyword
The new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The new operator also invokes 
the object constructor.


# What are local variables? Where are they stored?


# What is copy in java?
https://en.wikipedia.org/wiki/Object_copying#Copying_in_Java

# How does hashCode() work?

# Overload and Overwrite

# What exactly does ... do?


# Default methods in an interface
Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older 
versions of those interfaces.

You specify that a method definition in an interface is a default method with the default keyword at the beginning of the method signature. All method
declarations in an interface, including default methods, are implicitly public, so you can omit the public modifier.

!When you extend an interface that contains a default method, you can do the following
1. Not mention the default method at all, which lets your extended interface inherit the default method.
2. Redeclare the default method, which makes it abstract.
3. Redefine the default method, which overrides it.

# static methods in an inteface
In addition to default methods, you can define static methods in interfaces. (A static method is a method that is associated with the class in which 
it is defined rather than with any object. Every instance of the class shares its static methods.)

This makes it easier for you to organize helper methods in your libraries; you can keep static methods specific to an interface in the same interface 
rather than in a separate class. The following example defines a static method that retrieves a ZoneId object corresponding to a time zone identifier; 
it uses the system default time zone if there is no ZoneId object corresponding to the given identifier. (As a result, you can simplify the method 
getZonedDateTime)

Like static methods in classes, you specify that a method definition in an interface is a static method with the static keyword at the beginning of 
the method signature. All method declarations in an interface, including static methods, are implicitly public, so you can omit the public modifier.


# What does .class do ?
class after a class name, it references the class literal - java. lang. Class object that represents information about given class. For example, 
if your class is Print , then Print. class is an object that represents the class Print on runtime

# Can an abstract class extend a concrete class?
An abstract class always extends a concrete class ( java. lang. Object at the very least). So it works the same as it always does.

# static class:
You cannot use the static keyword with a class unless it is an inner class. A static inner class is a nested class which is a static member of 
the outer class. It can be accessed without instantiating the outer class, using other static members.