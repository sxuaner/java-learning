# Thread class is in java.lang package

# Definition of Thread
In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system.
 
#Thread and process 
The implementation of threads and processes differs between operating systems, but in most cases a thread is a component of a process. The multiple threads of a given process may be executed 
concurrently (via multithreading capabilities), sharing resources such as memory, while different processes do not share these resources. In particular, the threads of a process share its 
executable code and the values of its dynamically allocated variables and non-thread-local global variables at any given time.

## Multitasking
By definition, multitasking is when multiple processes share common processing resources such as a CPU.
##Multithreading
Multi-threading extends the idea of multitasking into applications where you can subdivide specific operations within a single application 
into individual threads. Each of the threads can run in parallel. The OS divides processing time not only among different applications, but also among each thread within an application.

#Parallelism and concurrency
http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html    (controversial)


#Thread Priorities
Every Java thread has a priority that helps the operating system determine the order in which threads are scheduled.Java thread priorities are in the range between MIN_PRIORITY (a constant of 1) and MAX_PRIORITY (a constant of 10). By default, every thread is given priority NORM_PRIORITY (a constant of 5).
When code running in some thread creates a new Thread object, the new thread has its priority initially set #equal to the priority of the creating thread#.

#How to implement Multithreading
1. implement the Runnable interface.
2. create a new class that extends #Thread class#

#Signature of the Thread Class: 
    [java]
        public class Thread extends Object implements Runnable{}
    [end]    
# Methods in thread class:
    [java]

        public final void setPriority(int priority){}
        public final void setDaemon(boolean on) {}          //A parameter of true denotes this Thread as a daemon thread.
    [end]
        
        ! The newly created object is a daemon thread if and only if the creating thread is a daemon
        !? what is daemon
        ! Components of some Linux desktop environments that are daemons include D-Bus, NetworkManager (here called unetwork), PulseAudio (usound), and Avahi. 
        ! In multitasking computer operating systems, a daemon (/ˈdiːmən/ or /ˈdeɪmən/) is a computer program that runs as a background process, rather than being under the direct control 
        ! of an interactive user. Traditionally, the process names of a daemon end with the letter d, for clarification that the process is in fact a daemon, and for differentiation between 
        ! a daemon and a normal computer program. For example, syslogd is a daemon that implements system logging facility, and sshd is a daemon that serves incoming SSH connections.

    [java]
        public final void join(long millisec) throws InterruptedException {} // The current thread invokes this method on a second thread, causing the current thread to block until the second thread terminates or the 
                                                                                // specified number of milliseconds passes.
    [end]

    [java]
        public void start(){}
        public void run(){}
    [end]
        !? Different between start() and run() method
        The difference is that Thread.start() starts a new thread that calls the run() method, while Runnable.run() just calls the run() method on the calling thread.
        See in link: https://stackoverflow.com/questions/8579657/whats-the-difference-between-thread-start-and-runnable-run

        !? If run() method is executed on the same thread, why is the interface Runnable needed? What is the purpose of this interface.
        // Runnable is a functional interface, which has only 1 method to implement: public void run()
        This interface Runnable is designed to provide a common protocol for objects that #wish to execute code while they are active#. For example, Runnable is implemented by class Thread. 
        Being active simply means that a thread has been started and has not yet been stopped.
        If a class implements Runnable interface, the objects of this class should not execute any code when they are not active according to the above protocol.
        In addition, Runnable provides the means for a class to be active while not subclassing Thread. 
        A class that implements Runnable can run without subclassing Thread by instantiating a Thread instance and passing itself in as the target. 
        // ?? see howto in thread project
        [java]
             class PrimeRun implements Runnable {
                 //...
                }
            // The following code would then create a new thread and start it running:
             PrimeRun p = new PrimeRun(143);
             new Thread(p).start();
        [end]
        
        // This means run() is executed on the thread itself
        In most cases, the Runnable interface should be used if you are only planning to override the run() method and no other Thread methods. 
        // This means if the program does not need multiple threads, the class should implement Runnable instead of subclassing the thread class. Reason why subclassing is not  recommended are 
        // as follows
        This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.
    [java]
    public void checkAccess()     // What is Security Manager???
    [end]

    [java]
    protected Object clone()  //Throws CloneNotSupportedException as a Thread can not be meaningfully cloned.
    [end]

    [java]
    public static Thread currentThread()     //Returns a reference to the currently executing thread object.
    [end]
    Example:

    [java]
    public static void dumpStack()  // Prints a stack trace of the current thread to the standard error stream. Example in thread project
    [end]

    [java]
    public final void join() throws InterruptedException
    [end]
    Thread class provides the join() method which allows one thread to wait until another thread completes its execution. If t is a Thread object whose thread is currently executing, then t. 
    join() will make sure that t is terminated before the next instruction is executed by the program.

    The join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing,
    causes the current thread to pause execution until t's thread terminates. Overloads of join allow the programmer to specify a waiting period. However, as with sleep, 
    join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify.
    Like sleep, join responds to an interrupt by exiting with an InterruptedException.


// join()
//Solutions using Join() do not answer the question - they ensure that the termination of the threads is ordered, not the running of them. 
//If the interviewr does not get that, you need to find another job anyway.


# ConcurrentHashMap    
When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). 
The Java Virtual Machine continues to execute threads until either of the following occurs
1. The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.
2. All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.
Types of locks


# ----------  Interview questions -------------
# 1. How to have three threads run after another? See thread-sequential example
// Happen after order
// t1,t2,t3 all implement Runnable and as normal objects instead of being threads, they can be executed one after another in sequential order
t1.run();
t2.run();
t3.run();

# 1. Assuming two threads should run in parallel, one solution would be to have each thread start the next one, since the JMM guarantees that:
! A call to start() on a thread happens-before any actions in the started thread. ???????????

# ----------
# Problem with starting a new thread in a JEE container
https://stackoverflow.com/questions/11713944/java-run-a-runnable-on-an-existing-thread

# How to validate that Thread.start() actually creates a new thread and runs it?
By putting a breakpoint inside the overriden run() method and run either start() or run() method to see the difference.
