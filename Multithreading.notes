# Thread class is in java.lang package

# Definition of Thread
In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system.
 
#Thread and process 
The implementation of threads and processes differs between operating systems, but in most cases a thread is a component of a process. The multiple threads of a given process may be executed 
concurrently (via multithreading capabilities), sharing resources such as memory, while different processes do not share these resources. In particular, the threads of a process share its 
executable code and the values of its dynamically allocated variables and non-thread-local global variables at any given time.

## Multitasking
By definition, multitasking is when multiple processes share common processing resources such as a CPU.
##Multithreading
Multi-threading extends the idea of multitasking into applications where you can subdivide specific operations within a single application 
into individual threads. Each of the threads can run in parallel. The OS divides processing time not only among different applications, but also among each thread within an application.

#Parallelism and concurrency
http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html    (controversial)


#Thread Priorities
Every Java thread has a priority that helps the operating system determine the order in which threads are scheduled.Java thread priorities are in the range between MIN_PRIORITY (a constant of 1) and MAX_PRIORITY (a constant of 10). By default, every thread is given priority NORM_PRIORITY (a constant of 5).
When code running in some thread creates a new Thread object, the new thread has its priority initially set #equal to the priority of the creating thread#.

#How to implement Multithreading
1. implement the Runnable interface.
2. create a new class that extends #Thread class#

#Signature of the Thread Class: 
    [java]
        public class Thread extends Object implements Runnable{}
    [end]    
# Methods in thread class:
    [java]

        public final void setPriority(int priority){}
        public final void setDaemon(boolean on) {}          //A parameter of true denotes this Thread as a daemon thread.
    [end]
        
        ! The newly created object is a daemon thread if and only if the creating thread is a daemon
        !? what is daemon
        ! Components of some Linux desktop environments that are daemons include D-Bus, NetworkManager (here called unetwork), PulseAudio (usound), and Avahi. 
        ! In multitasking computer operating systems, a daemon (/ˈdiːmən/ or /ˈdeɪmən/) is a computer program that runs as a background process, rather than being under the direct control 
        ! of an interactive user. Traditionally, the process names of a daemon end with the letter d, for clarification that the process is in fact a daemon, and for differentiation between 
        ! a daemon and a normal computer program. For example, syslogd is a daemon that implements system logging facility, and sshd is a daemon that serves incoming SSH connections.

    [java]
        public final void join(long millisec) throws InterruptedException {} // The current thread invokes this method on a second thread, causing the current thread to block until the second thread terminates or the 
                                                                                // specified number of milliseconds passes.
    [end]

    [java]
        public void start(){}
        public void run(){}
    [end]
        !? Different between start() and run() method
        The difference is that Thread.start() starts a new thread that calls the run() method, while Runnable.run() just calls the run() method on the calling thread.
        See in link: https://stackoverflow.com/questions/8579657/whats-the-difference-between-thread-start-and-runnable-run

        !? If run() method is executed on the same thread, why is the interface Runnable needed? What is the purpose of this interface.
        // Runnable is a functional interface, which has only 1 method to implement: public void run()
        This interface Runnable is designed to provide a common protocol for objects that #wish to execute code while they are active#. For example, Runnable is implemented by class Thread. 
        Being active simply means that a thread has been started and has not yet been stopped.
        If a class implements Runnable interface, the objects of this class should not execute any code when they are not active according to the above protocol.
        In addition, Runnable provides the means for a class to be active while not subclassing Thread. 
        A class that implements Runnable can run without subclassing Thread by instantiating a Thread instance and passing itself in as the target. 
        // ?? see howto in thread project
        [java]
             class PrimeRun implements Runnable {
                 //...
                }
            // The following code would then create a new thread and start it running:
             PrimeRun p = new PrimeRun(143);
             new Thread(p).start();
        [end]
        
        // This means run() is executed on the thread itself
        In most cases, the Runnable interface should be used if you are only planning to override the run() method and no other Thread methods. 
        // This means if the program does not need multiple threads, the class should implement Runnable instead of subclassing the thread class. Reason why subclassing is not  recommended are 
        // as follows
        This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.
    [java]
    public void checkAccess()     // What is Security Manager???
    [end]

    [java]
    protected Object clone()  //Throws CloneNotSupportedException as a Thread can not be meaningfully cloned.
    [end]

    [java]
    public static Thread currentThread()     //Returns a reference to the currently executing thread object.
    [end]
    Example:

    [java]
    public static void dumpStack()  // Prints a stack trace of the current thread to the standard error stream. Example in thread project
    [end]

    [java]
    public final void join() throws InterruptedException
    [end]
    Thread class provides the join() method which allows one thread to wait until another thread completes its execution. If t is a Thread object whose thread is currently executing, then t. 
    join() will make sure that t is terminated before the next instruction is executed by the program.

    The join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing,
    causes the current thread to pause execution until t's thread terminates. Overloads of join allow the programmer to specify a waiting period. However, as with sleep, 
    join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify.
    Like sleep, join responds to an interrupt by exiting with an InterruptedException.


// join()
//Solutions using Join() do not answer the question - they ensure that the termination of the threads is ordered, not the running of them. 
//If the interviewr does not get that, you need to find another job anyway.


# ConcurrentHashMap    
When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). 
The Java Virtual Machine continues to execute threads until either of the following occurs
1. The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.
2. All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.
Types of locks


# ----------  Interview questions -------------
# 1. How to have three threads run after another? See thread-sequential example
// Happen after order
// t1,t2,t3 all implement Runnable and as normal objects instead of being threads, they can be executed one after another in sequential order
t1.run();
t2.run();
t3.run();

# 1. Assuming two threads should run in parallel, one solution would be to have each thread start the next one, since the JMM guarantees that:
! A call to start() on a thread happens-before any actions in the started thread. ???????????

# ----------
# Problem with starting a new thread in a JEE container
https://stackoverflow.com/questions/11713944/java-run-a-runnable-on-an-existing-thread

# How to validate that Thread.start() actually creates a new thread and runs it?
By putting a breakpoint inside the overriden run() method and run either start() or run() method to see the difference.


# What is the nature of Java Thread?
https://stackoverflow.com/questions/18278425/are-java-threads-created-in-user-space-or-kernel-space
1. 
Java threads are "user" threads, but under the hood, the Java Virtual Machine is using kernel threads and delegating 
the user threads CPU time on each kernel thread in its kernel thread pool. See this question for a better explanation. 
It seems that threading is JVM-vendor specific, and my understanding might not hold for all JVM implementations.
2. 
Most JVMs implement threads with native, OS level threads, including the Oracle reference implementation based on OpenJDK.

I imagine the JVMs that use 'green threads' (user space simulation of threads) would use preemptive scheduling so that 
an infinite loop in one thread doesn't block the other threads, but without knowledge of a particular implementation 
this is just speculation.

https://stackoverflow.com/questions/2653458/understanding-javas-native-threads-and-the-jvm

# Understanding Java native thread and the jvm
Answer1:
1. Does every thread create their own instance of the JVM to handle their particular execution?
No. They execute in the same JVM so that (for example) they can share objects and class attributes.

2. If not then does the JVM have to have some way to schedule which thread it will handle next
There are two kinds of thread implementation in Java. Native threads are mapped onto a thread abstraction which is 
implemented by the host OS. The OS takes care of native thread scheduling, and time slicing.

The second kind of thread is "green threads". These are implemented and managed by the JVM itself, with the JVM 
implementing thread scheduling. Java green thread implementations have not been supported by Sun / Oracle JVMs since 
Java 1.2. (See Green Threads vs Non Green Threads)

If so wouldn't this render the multi-threaded nature of Java useless since only one thread can be ran at a time?
We are talking about green threads now, and this is of historic interest (only) from the Java perspective.

Green threads have the advantage that scheduling and context switching are faster in the non-I/O case. (Based on 
measurements made with Java on Linux 2.2; http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.9238)
With pure green threads, N programming language threads are mapped to a single native thread. In this model you don't 
get true parallel execution, as you noted.
In a hybrid thread implementation, N programming language threads are mapped onto M native threads (where N > M). In 
this model, the in-process thread scheduler is responsible for the green thread to native thread scheduling AND you g
et true parallel execution (if M > 1); see https://stackoverflow.com/a/16965741/139985.
But even with the pure green threads, you still get concurrency. Control is switched to another threads a thread 
blocks on an I/O operation, whick acquiring a lock, and so on. Furthermore, the JVM's runtime could implement periodic 
thread preemption so that a CPU intensive thread doesn't monopolize the (single) core to the exclusion of other threads


#Answer2:
Does every thread create their own instance of the jvm to handle their particular execution?
No, your application running in the JVM can have many threads that all exist within that instance of the JVM.

If not then does the jvm have to have some way to schedule which thread it will handle next...
Yes, the JVM has a thread scheduler. There are many different algorithms for thread scheduling, and which one is used is JVM-vendor dependent. (Scheduling in general is an interesting topic.)

...if so wouldn't this render the multi-threaded nature of java useless since only one thread can be ran at a time?
I'm not sure I understand this part of your question. This is kind of the point of threading. You typically have more 
threads than CPUs, and you want to run more than one thing at a time. Threading allows you to take full(er) advantage 
of your CPU by making sure it's busy processing one thread while another is waiting on I/O, or is for some other 
reason not busy.

Answer3:
A Java thread may be mapped one-to-one to a kernel thread. But this must not be so. There could be n kernel threads running m java threads, 
where m may be much larger than n, and n should be larger than the number of processors. The JVM itself starts the n kernel threads, and 
each one of them picks a java thread and runs it for a while, then switches to some other java thread. The operating system picks kernel threads 
and assigns them to a cpu. So there may be thread scheduling on several levels. You may be interested to look at the GO programming language, 
where thousands of so called "Goroutines" are run by dozens of threads.

!?How exactly is the mapping of java thread to kernel thread? 1:1 or n:m?

# Scheduling is a interesting topc
https://en.wikipedia.org/wiki/Scheduling_%28computing%29


# Green thread and non-green thread
https://stackoverflow.com/questions/5713142/green-threads-vs-non-green-threads


# Sleep method
https://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html